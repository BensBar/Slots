<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phenomenal 4K Slot Machine Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: radial-gradient(circle, #1a1a1a, #000);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            color: gold;
            font-family: 'Arial Black', sans-serif;
            text-shadow: 0 0 10px #ff4500;
        }
        #game-container {
            position: relative;
            width: 90vw;
            max-width: 2560px; /* 4K ready */
            aspect-ratio: 16/9;
            overflow: hidden;
            border: 5px solid gold;
            box-shadow: 0 0 50px gold;
            background: url('data:image/svg+xml,%3Csvg xmlns="http://2000.svg" viewBox="0 0 100 100"%3E%3Crect width="100" height="100" fill="black"/%3E%3Ccircle cx="50" cy="50" r="40" fill="none" stroke="gold" stroke-width="2" stroke-dasharray="5,5"/%3E%3C/svg%3E');
            background-size: cover;
        }
        #slot-canvas {
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(51,51,51,0.8);
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
            gap: 10px;
        }
        #balance, #bet-amount {
            font-size: 1.8em;
            margin: 0 10px;
        }
        #spin-button, #auto-spin-button, #paytable-button, #bet-up, #bet-down {
            padding: 12px 25px;
            font-size: 1.4em;
            background-color: #ff4500;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 8px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        #spin-button:hover, #auto-spin-button:hover, #paytable-button:hover, #bet-up:hover, #bet-down:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px #ff4500;
        }
        #spin-button:disabled, #auto-spin-button:disabled {
            background-color: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        #message {
            font-size: 1.8em;
            margin-top: 10px;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            width: 100%;
            text-align: center;
        }
        #paytable {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 10px;
            display: none;
            z-index: 10;
            color: white;
            max-width: 80%;
            overflow: auto;
        }
        #paytable h2 {
            text-align: center;
        }
        #paytable ul {
            list-style: none;
            padding: 0;
        }
        #paytable li {
            margin: 10px 0;
        }
        #close-paytable {
            float: right;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="slot-canvas"></canvas>
    </div>
    <div id="controls">
        <div id="balance">Balance: 1000</div>
        <button id="bet-down">-</button>
        <div id="bet-amount">Bet: 10</div>
        <button id="bet-up">+</button>
        <button id="spin-button">Spin</button>
        <button id="auto-spin-button">Auto Spin</button>
        <button id="paytable-button">Paytable</button>
        <div id="message"></div>
    </div>
    <div id="paytable">
        <span id="close-paytable">X</span>
        <h2>Paytable</h2>
        <ul>
            <li>Cherry x3: 20x</li>
            <li>Lemon x3: 30x</li>
            <li>Clover x3: 40x</li>
            <li>Bell x3: 50x</li>
            <li>Star x3: 100x (Scatter - 3+ triggers free spins)</li>
            <li>Seven x3: 200x</li>
            <li>Jackpot x3: 500x</li>
            <li>Diamond x3: 1000x (Wild - substitutes for all except scatter)</li>
            <li>3 Bells: Bonus Round</li>
        </ul>
        <p>Free Spins: 3+ Star gives 10 free spins with 2x multiplier.</p>
        <p>Bonus Round: Pick from prizes for extra credits.</p>
    </div>
    <audio id="spin-sound" src="https://orangefreesounds.com/wp-content/uploads/2024/12/Slot-machine-sound-effect.mp3" preload="auto"></audio>
    <audio id="win-sound" src="https://orangefreesounds.com/wp-content/uploads/2024/12/Slot-machine-sound-effect.mp3" preload="auto"></audio> <!-- Use same for now -->
    <script>
        // Phenomenal Slot Machine Game Logic with 4K Sizzle and PNG Assets
        const canvas = document.getElementById('slot-canvas');
        const ctx = canvas.getContext('2d');
        const spinButton = document.getElementById('spin-button');
        const autoSpinButton = document.getElementById('auto-spin-button');
        const betUp = document.getElementById('bet-up');
        const betDown = document.getElementById('bet-down');
        const balanceElem = document.getElementById('balance');
        const betAmountElem = document.getElementById('bet-amount');
        const messageElem = document.getElementById('message');
        const paytableButton = document.getElementById('paytable-button');
        const paytable = document.getElementById('paytable');
        const closePaytable = document.getElementById('close-paytable');
        const spinSound = document.getElementById('spin-sound');
        const winSound = document.getElementById('win-sound');

        // Game Constants
        const REELS = 5;
        const ROWS = 3;
        const SYMBOL_KEYS = ['cherry', 'lemon', 'clover', 'bell', 'star', 'seven', 'jackpot', 'diamond']; // Mapped to PNG files, wild is diamond
        const REEL_STRIP_LENGTH = SYMBOL_KEYS.length * 5; // Even longer for smoothness
        const SPIN_DURATION = 3000; // Dramatic spin
        const BET_STEP = 10;
        const MIN_BET = 10;
        const MAX_BET = 100;
        const PAYLINES = [
            [1,1,1,1,1], // Middle
            [0,0,0,0,0], // Top
            [2,2,2,2,2], // Bottom
            [0,1,2,1,0], // V
            [2,1,0,1,2], // Inverted V
            [0,0,1,2,2], // Diagonal down
            [2,2,1,0,0], // Diagonal up
            [1,0,0,0,1], // W shape
            [1,2,2,2,1], // M shape
            [0,1,0,1,0] // Zigzag
        ];
        const PAYTABLE = {
            'cherrycherrycherry': 20,
            'lemonlemonlemon': 30,
            'clovercloverclover': 40,
            'bellbellbell': 50,
            'starstarstar': 100,
            'sevensevenseven': 200,
            'jackpotjackpotjackpot': 500,
            'diamonddiamonddiamond': 1000
        };
        const FREE_SPINS_COUNT = 10;
        const FREE_SPINS_MULTIPLIER = 2;

        // Load PNG images
        const symbolImages = {};
        SYMBOL_KEYS.forEach(key => {
            symbolImages[key] = new Image();
            symbolImages[key].src = `/assets/${key}.png`;
        });
        const wildKey = 'diamond'; // Wild
        const scatterKey = 'star'; // Scatter
        const bonusKey = 'bell'; // Bonus trigger

        // Game State
        let balance = localStorage.getItem('balance') ? parseInt(localStorage.getItem('balance')) : 1000;
        let betAmount = MIN_BET;
        let isSpinning = false;
        let autoSpinning = false;
        let freeSpins = 0;
        let reelPositions = Array(REELS).fill(0);
        let reelVelocities = Array(REELS).fill(0);
        let reelTargets = Array(REELS).fill(0);
        let reelStrips = Array(REELS).fill().map(() => generateReelStrip());
        let lastFrameTime = 0;
        let particles = [];
        let winningLines = [];
        let bonusRound = false;
        let imagesLoaded = 0;
        const totalImages = SYMBOL_KEYS.length;

        // Wait for images to load
        SYMBOL_KEYS.forEach(key => {
            symbolImages[key].onload = () => {
                imagesLoaded++;
                if (imagesLoaded === totalImages) {
                    resizeCanvas();
                    requestAnimationFrame(animate);
                }
            };
        });

        // Scale for 4K
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            render();
        }
        window.addEventListener('resize', resizeCanvas);

        // Generate reel strip with more variety
        function generateReelStrip() {
            let strip = [];
            for (let i = 0; i < 5; i++) {
                strip = strip.concat(SYMBOL_KEYS.sort(() => Math.random() - 0.5));
            }
            return strip;
        }

        // Render with enhanced visuals
        function render() {
            if (imagesLoaded < totalImages) return; // Wait for load

            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const reelWidth = width / REELS;
            const rowHeight = height / ROWS;
            const symbolSize = Math.min(reelWidth * 0.8, rowHeight * 0.8);
            const marginX = (reelWidth - symbolSize) / 2;
            const marginY = (rowHeight - symbolSize) / 2;

            ctx.clearRect(0, 0, width, height);

            // Draw reel backgrounds with metallic gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#555');
            gradient.addColorStop(1, '#111');
            for (let i = 0; i < REELS; i++) {
                ctx.fillStyle = gradient;
                ctx.fillRect(i * reelWidth, 0, reelWidth, height);
            }

            // Draw symbols from PNGs with glow and shadow
            for (let reel = 0; reel < REELS; reel++) {
                for (let row = -1; row <= ROWS; row++) {
                    const pos = (reelPositions[reel] + row + REEL_STRIP_LENGTH) % REEL_STRIP_LENGTH;
                    const symbolKey = reelStrips[reel][Math.floor(pos)];
                    const frac = pos % 1;
                    const x = reel * reelWidth + marginX;
                    const y = row * rowHeight + (frac * rowHeight) + marginY;

                    ctx.shadowColor = 'gold';
                    ctx.shadowBlur = 10;
                    ctx.drawImage(symbolImages[symbolKey], x, y, symbolSize, symbolSize);
                    ctx.shadowBlur = 0;
                }
            }

            // Draw paylines with glow
            ctx.strokeStyle = 'rgba(255,215,0,0.5)';
            ctx.lineWidth = 5;
            for (let line of PAYLINES) {
                ctx.beginPath();
                for (let i = 0; i < REELS; i++) {
                    const x = i * reelWidth + reelWidth / 2;
                    const y = line[i] * rowHeight + rowHeight / 2;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // Highlight winning lines with animation
            if (winningLines.length > 0) {
                const time = Date.now() / 1000;
                ctx.strokeStyle = `rgba(255, 0, 0, ${Math.sin(time * 10) * 0.5 + 0.5})`;
                ctx.lineWidth = 8;
                for (let idx of winningLines) {
                    const line = PAYLINES[idx];
                    ctx.beginPath();
                    for (let i = 0; i < REELS; i++) {
                        const x = i * reelWidth + reelWidth / 2;
                        const y = line[i] * rowHeight + rowHeight / 2;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
            }

            // Render particles with glow
            particles.forEach(p => {
                ctx.fillStyle = `rgba(255,215,0,${p.alpha})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                p.y -= p.speed;
                p.alpha -= 0.005;
                p.size += 0.2;
            });
            particles = particles.filter(p => p.alpha > 0);
        }

        // Animation loop
        function animate(time) {
            if (!lastFrameTime) lastFrameTime = time;
            const delta = (time - lastFrameTime) / 16;
            lastFrameTime = time;

            if (isSpinning) {
                let stillSpinning = false;
                for (let i = 0; i < REELS; i++) {
                    if (reelVelocities[i] > 0) {
                        reelPositions[i] += reelVelocities[i] * delta;
                        const dist = (reelTargets[i] - reelPositions[i] + REEL_STRIP_LENGTH) % REEL_STRIP_LENGTH;
                        if (dist < 5) reelVelocities[i] *= 0.92; // Smooth decelerate
                        if (reelVelocities[i] < 0.01) {
                            reelVelocities[i] = 0;
                            reelPositions[i] = reelTargets[i];
                            // Bounce effect
                            reelPositions[i] -= 0.2;
                            setTimeout(() => reelPositions[i] += 0.2, 100);
                        }
                        reelPositions[i] %= REEL_STRIP_LENGTH;
                        stillSpinning = true;
                    }
                }
                if (!stillSpinning) {
                    isSpinning = false;
                    spinButton.disabled = false;
                    checkWins();
                    if (autoSpinning || freeSpins > 0) {
                        setTimeout(startSpin, 1000);
                    }
                }
            }

            render();
            requestAnimationFrame(animate);
        }

        // Start spin
        function startSpin() {
            if (balance < betAmount && freeSpins === 0) {
                messageElem.textContent = 'Insufficient balance!';
                autoSpinning = false;
                autoSpinButton.textContent = 'Auto Spin';
                return;
            }
            if (freeSpins === 0) {
                balance -= betAmount;
            } else {
                freeSpins--;
                messageElem.textContent = `Free Spins left: ${freeSpins}`;
            }
            updateBalance();
            messageElem.textContent = '';
            isSpinning = true;
            spinButton.disabled = true;
            winningLines = [];
            spinSound.play();

            for (let i = 0; i < REELS; i++) {
                reelVelocities[i] = 1.2 + Math.random() * 0.8;
                reelTargets[i] = Math.floor(Math.random() * REEL_STRIP_LENGTH);
            }
        }

        // Check wins with wild and scatter
        function checkWins() {
            let totalPayout = 0;
            const grid = getGrid();
            winningLines = [];

            // Check paylines
            for (let l = 0; l < PAYLINES.length; l++) {
                let symbols = PAYLINES[l].map((row, reel) => grid[row][reel]);
                // Wild substitution (simple: replace wild with the first non-wild symbol in the line)
                const firstNonWild = symbols.find(s => s !== wildKey) || wildKey;
                symbols = symbols.map(s => s === wildKey ? firstNonWild : s);
                let key = symbols.join('');
                let payout = PAYTABLE[key] || 0;
                if (payout > 0) {
                    totalPayout += payout;
                    winningLines.push(l);
                }
            }

            // Scatter check
            let scatterCount = 0;
            for (let row = 0; row < ROWS; row++) {
                for (let reel = 0; reel < REELS; reel++) {
                    if (grid[row][reel] === scatterKey) scatterCount++;
                }
            }
            if (scatterCount >= 3) {
                totalPayout += 50 * scatterCount;
                freeSpins += FREE_SPINS_COUNT;
                messageElem.textContent += ' + Free Spins!';
            }

            // Bonus round if 3 bells
            let bonusCount = 0;
            for (let row = 0; row < ROWS; row++) {
                for (let reel = 0; reel < REELS; reel++) {
                    if (grid[row][reel] === bonusKey) bonusCount++;
                }
            }
            if (bonusCount >= 3) {
                bonusRound = true;
                totalPayout += Math.floor(Math.random() * 500 + 100); // Random bonus
                messageElem.textContent += ' + Bonus Win!';
            }

            // Apply multiplier if in free spins
            if (freeSpins > 0) totalPayout *= FREE_SPINS_MULTIPLIER;

            if (totalPayout > 0) {
                balance += totalPayout * betAmount;
                messageElem.textContent = `Epic Win! ${totalPayout}x bet = ${totalPayout * betAmount}`;
                winSound.play();
                createParticles();
            } else {
                messageElem.textContent = 'Try Again!';
            }
            updateBalance();
        }

        function getGrid() {
            const grid = Array.from({length: ROWS}, () => Array(REELS).fill(''));
            for (let reel = 0; reel < REELS; reel++) {
                for (let row = 0; row < ROWS; row++) {
                    const pos = (Math.floor(reelPositions[reel]) + row) % REEL_STRIP_LENGTH;
                    grid[row][reel] = reelStrips[reel][pos];
                }
            }
            return grid;
        }

        // Particle explosion with more variety
        function createParticles() {
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            for (let i = 0; i < 100; i++) {
                particles.push({
                    x: Math.random() * width,
                    y: height,
                    size: Math.random() * 8 + 2,
                    speed: Math.random() * 3 + 2,
                    alpha: 1
                });
            }
        }

        function updateBalance() {
            balanceElem.textContent = `Balance: ${balance}`;
            betAmountElem.textContent = `Bet: ${betAmount}`;
            localStorage.setItem('balance', balance);
        }

        // Event listeners
        spinButton.addEventListener('click', startSpin);
        autoSpinButton.addEventListener('click', () => {
            autoSpinning = !autoSpinning;
            autoSpinButton.textContent = autoSpinning ? 'Stop Auto' : 'Auto Spin';
            if (autoSpinning) startSpin();
        });
        betUp.addEventListener('click', () => {
            if (betAmount < MAX_BET) betAmount += BET_STEP;
            updateBalance();
        });
        betDown.addEventListener('click', () => {
            if (betAmount > MIN_BET) betAmount -= BET_STEP;
            updateBalance();
        });
        paytableButton.addEventListener('click', () => paytable.style.display = 'block');
        closePaytable.addEventListener('click', () => paytable.style.display = 'none');

        updateBalance();
    </script>
</body>
</html>